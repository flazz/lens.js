// Generated by CoffeeScript 1.4.0
var o;

o = {
  a: {
    aa: 1
  },
  b: {
    bb: 2
  },
  c: {
    cc: [1, 2]
  }
};

describe('lens.js', function() {
  var a, l;
  o = null;
  a = null;
  l = null;
  describe('arrays focus via indexes', function() {
    beforeEach(function() {
      o = [1, 2, 3];
      return l = L.lens(2);
    });
    it('get the focus', function() {
      return expect(l.get(o)).toEqual(3);
    });
    return it('set the focus', function() {
      return expect(l.set(o, 0)).toEqual([1, 2, 0]);
    });
  });
  describe('objects focus via keys', function() {
    beforeEach(function() {
      o = {
        a: 0,
        b: 1
      };
      return l = L.lens('a');
    });
    it('get the focus', function() {
      return expect(l.get(o)).toEqual(0);
    });
    return it('set the focus', function() {
      return expect(l.set(o, 2)).toEqual({
        a: 2,
        b: 1
      });
    });
  });
  describe('composition', function() {
    beforeEach(function() {
      o = {
        a: [100, 200]
      };
      return l = L.compose(L.lens(0), L.lens('a'));
    });
    it('focus on the focus (of another lens)', function() {
      expect(l.get(o)).toEqual(100);
      return expect(l.set(o, 1)).toEqual({
        a: [1, 200]
      });
    });
    it('can compose a path of foci', function() {
      var lPath;
      lPath = L.path(['a', 0]);
      expect(lPath.get(o)).toEqual(l.get(o));
      return expect(lPath.set(o, 1)).toEqual(l.set(o, 1));
    });
    return it('calling L is a shorthand for path', function() {
      var lCall, lPath;
      lPath = L.path(['a', 0]);
      lCall = L('a', 0);
      expect(lCall.get(o)).toEqual(lPath.get(o));
      return expect(lCall.set(o, 1)).toEqual(lPath.set(o, 1));
    });
  });
  describe('modify', function() {
    return it('sets a function of get', function() {
      var o2;
      o = {
        a: 0
      };
      l = L.lens('a');
      o2 = L.mod(l, o, function(v) {
        return v + 1;
      });
      return expect(o2).toEqual({
        a: 1
      });
    });
  });
  return describe('zip', function() {
    return it('focus on many lenses at once', function() {
      o = {
        xs: [100, 200]
      };
      l = L.zip(L('xs'), L('ys'), L('zs'));
      expect(l.get(o)).toEqual([[100, 200], void 0, void 0]);
      return expect(l.set(o, [1, 2, 3])).toEqual({
        xs: 1,
        ys: 2,
        zs: 3
      });
    });
  });
});

/* TODO predicate selectors in path, does it violate the laws?
##L('c', 'cc', (ix) -> ix == 4)
##L('a', (k) -> k == 'aa')
## could define ix() or k()

## TODO parallelisms, does it violate the laws?
##L(union('a', 'c'))

#console.log "\n# zip ..."
#console.log "[a.aa, d]", do ->
  #lz = L.zip L('a', 'aa'), L('d')
  #lz.get o

#console.log "[a.aa, d] = [a.aa, a.aa]:", do ->
  #lz = L.zip L('a', 'aa'), L('d')
  #[x, _y] = lz.get o
  #lz.set o, [x, x]

#console.log "mod [a.aa, d] = [a.aa, a.aa]:", do ->
  #lz = L.zip L('a', 'aa'), L('d')
  #[x, _y] = lz.get o
  #lz.set o, [x, x]
*/

